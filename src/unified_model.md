# 统一存储模型

## 对文件/目录统一的一些思考

上述的设计中，将普通文件/目录文件/链接文件都抽象为bucket的形式，文件相关的内容全部表示为键值对的形式，此时不同文件的表示已经初步得到了统一。此时可以更近一步，不再区分传统意义上文件/目录，**一个bucket就对应一个存储数据的载体**,用户可以认为这是一个普通文件，或是一个目录，或是一个链接文件，只需要在这个bucket存储一条key-value对，比如`type:Normal file`  `type:Directory` `type:Symlink` 来进行区别, 而**在传统文件系统中权限控制和属性列表 此时也可以全部交给用户指定( 注: 这里需要考虑是不是所有的内容都由用户控制，在现在的操作系统中，这显然是不行的，因为多用户系统就是为了进行权限控制，因此我们可以规定bucket存储一些操作系统规定的内容)**。用户可以在一个bucket中创建`author: linfeng`  `ctime:2023.1.1` 键值对以表明这个bucket的作者是linfeng,创建的时间是2023.1.1。如果用户想要插入数据，那么就在bucket中插入一条键值对，如果想要插入多条数据，那么用户就可以对这些数据做一个预处理保证键的唯一性（bucket的键是唯一的，一个简单的方法是唯一键生成方式可以是当前的时间）再将这些数据插入到bucket中。用户可以根据其保存数据时创建的key来对信息进行读取。

 bucket存储的内容全部交给用户管理，那么传统的文件系统结构就不存在了，传统的关于文件系统的系统调用语义也就不同了。当然我认为这是必然出现的事情，传统的文件系统相关调用，比如`ls` `cat` `read` `write`等隐含地表示了要操作的对象是文件或者是目录，而现在已经不存在这种区别了，那么统一的bucket表达形式如何完成这些系统调用想要完成的功能呢？这里有两种方式可以选择:

### 1. 使用统一的bucket模拟传统文件系统

这种方式就是上述dbfs的设计方式，这种设计方式可以完全按照传统文件系统的运行方式运行。但是可以看到，这个时候bucket存储的数据已经被设计者人为进行了一些限制，因为里面不同类型的bucket代表了不同的文件类型，用户只能对bucket进行规定的操作。

### 2.抛弃原有的系统调用以及其语义

如果不关注原有的系统调用，而是根据这种统一的设计设计新的系统调用，那么就应该关注用户在使用文件时想要做什么？需要做什么？在传统意义上，用户使用文件来保存数据，并且为了更好组织这些文件引入了目录，为了便利和资源的有效利用又引入了链接文件，这就是用户想要做的事情，保存数据的方式很简单，任何一种不太复杂的数据结构都可以成为文件用来保存数据，而引入目录之后，磁盘上存储的东西就不只是单纯的文件数据了，需要增加新的数据结构来适应这种变化，因此在目录中存储的数据就变成了目录项，用来指向文件的所在位置。而硬链接的引入则需要使得多个文件名指向同一份文件数据，这就需要一种标识使得文件数据变得唯一，inode的设计很好地完成了这个工作。这些用户想要的东西，在统一模型上如何实现呢？



#### 思路

上述文中提到，key-value数据库提供了`key-data`   和 `key-bucket` 的数据结构，这两种数据结构可以形成嵌套的结构。

![fs3](assert/fs3-16788875152432.svg)

- bucket不分类型，数据全部由key-value对构成，value可以是data([u8])，也可以是bucket，这个bucket可以是**全局空间的bucket.**，也可以是**局部嵌套的bucket**，上图中1、2、4指向的就是全局bucket，5指向的是局部嵌套的bucket, 两者的区别是全局的bucket需要一个标识进行间接跳转，比如1对应的'bucket1' 就是全局空间的bucket的标识， 而局部嵌套的不需要跳转，直接访问。创建哪种类型的bucket将由用户决定。

- <font color=red>我们将这些键值对分为叶子键值对与非叶子键值对, 叶子键值对只包含一种类型，即value为[u8]数组，且这个数组的信息没有指向一个全局的bucket(图中1位置)， 而非叶子键值对则说明这个value可能是一个bucket，也可能是指向全局空间中的bucket标识符</font>

- **bucket的一部分key-value将被操作系统固定，比如权限控制相关的uid/gid/xwr, 时间相关的atime/ctime/mtime,这些字段可以被用户修改或者访问，但是不允许删除掉，其它的key-value将交给用户来进行控制。**

- 除了系统控制的其它key-value对由用户进行解释，由于比如对一个`bucket0:file1` (在bucket0中key为file1) ， 用户需要传递一个函数以解释如何对这个key对应的value进行解释/操作，用户提供的函数形式为

  ```rust
  enum Para<'a>{
      Data(&'a [u8]),
      Bucket(bucket),
  }
  fn (p:Para,buf:&mut[u8])
  ```

  那么内核数据库中查找到这个key时，根据其value构建para并调用用户传递的函数并执行。

  对于这样bucket数据由用户进行解释的需求，是否可以将原来那些文件系统相关系统调用统一为一个系统调用？其形式大致是

  ```rust
  enum Para<'a>{
      Data(&'a [u8]),
      Bucket(bucket),
  }
  fn syscall_interpretate(path:&str,buf:&mut[u8],func:fn(p:Para,buf:&mut[u8]))
  // func: 桶/[u8]的解析函数
  ```

  此时原来那些系统调用完成的事情由用户提供的`func`完成。

  这里牵扯到的一个问题是是否保留传统文件系统中路径游走和缓存的概念，当然这里路径游走的概念与传统的有点细微差别，这里的含义是指用户解释一个级联键值对时是否需要一个类似vfs层的结构来缓存遇到的bucket结构，从而在下一次在访问这个bucket时加速查找而不是从头开始查找。因为在这个统一模型下，如果出现buckt级联的情况，那么当用户需要解释一个较长的键值对时，比如根据上图所示的: `bucket0:file2:fil2:data` 

  1. 不需要路径游走和缓存

     对于这个级联的键值对，从第一个bucket0开始查找，找到其key {file2} 对应的value， 上图中是'bucket2'，那么再查找全局空间中bucket2, 再找到其key {fil2} 对应的value {bucket4}, 再到全局空间查找到bucket4， 最后找到 key{data} 指向的数据

  2. 存在路径游走和缓存的概念

     内核空间中存在类似于vfs的数据结构，用以缓存bucket的信息，缓存的信息就是bucket中的键值对，在第一次访问时从磁盘上读取信息并缓存。那么对这个级联的键值对，就不需要每次到磁盘进行查找，可能只需要在内存中查找就可以得到。

  更近一步的，对于这些级联的key-value对，每一个分量的处理是一样的吗？从上述所说肯定是不一样的，比如 级联对`bucket0:file2:fil2:data` ，如果用户提供的处理函数是对应这个data对应的数据，那么前面的`:file2:file2`系统又应该如何解释呢，**需要让用户把每一级的处理函数都提供吗?**这里就存在一个**默认实现** 的问题，因为要存在这种级联的键值对处理，说明用户中间那些键值对就是**非叶子键值对**，那么在对这种级联键值对处理时，中间的键值对处理按照进入下一个bucket处理。用户提供的处理函数只针对最后一个叶子键值对分量，这样可以一定程度上减少用户的负担。

  

  那么考虑到默认实现，我们是否可以为用户提供一些现成的，简单的处理函数使用呢，因为很多时候用户可能就是想看一下这个key对应value是什么，那么只需要一个简单的打印字符串或者打印[u8]数组函数。比如我们可以提供下面这种简单的函数:

  ```rust
  fn print_value_with_string(para) //将value解析为字符串打印
  fn print_value_with_u8array(para) //将value直接打印不解析
  fn read_data(para,buf) // 读取value的内容到buf中
  fn write_data(para,buf) // 修改value的内容
  
  fn add_key_data(para,buf) //插入一条新的叶子键值对
  fn add_bucket(para,global:bool) //插入一个非叶子键值对
  fn delete_key(para) //删除一条键值对
  
  fn step_into(para) // 进入value所对应的bucket
  ```

  对于级联对`bucket0:file2:fil2:data` 来说，处理时中间分量默认使用`step_into` ，末尾分量由用户定义的函数处理。


  
### 3.统一语义与DBFS相结合

<font color=red>为了与传统的文件系统兼容，统一模型仍然需要找到合适的方式适应VFS, 或者说做一个胶水层，将传统的VFS层与这个模型糅合起来(flatfs启发)，不管那种方式，都有点点丑陋。</font>

另一种方案是利用上面设计的DBFS与统一语义结合。可以看到，DBFS应该是统一模型中的一个子集，通过对统一模型进行限制，就可以变成DBFS, 那么这就带来一个好处，我们可以在数据库之上构建DBFS以满足应用程序的传统文件系统需求，并暴露一些系统调用，当用户使用原有的文件系统相关系统调用时，默认使用DBFS完成功能，而当用户调用**扩展的系统调用**时，我们将按照统一模型进行处理。当然用户也可以直接忽略DBFS的存在，而完全使用统一模型的思路，这当然是更好的。

不过这里的一个待解决问题是由于DBFS已经占用了一些key-value对，比如以“data”开头的存储数据的那些键，用户在即使用DBFS又使用统一模型的情况下，可能会造成**键冲突**，因此需要考虑是否可以对DBFS部分的那些key做混淆，使用一些在用户定义的key中不太会出现的字符进行标识？这样用户在使用统一模型时就能减少一部分键冲突。




## 一些传统操作在这个统一模型上的体现

**create** : 传统的文件系统中这个操作一般用于创建文件，统一模型中则对应于创建一个key-value对，这个键值对可以表达用户的任意想法，当用户只是简单地为这个存储桶添加一条信息时，其可以使用`add_key_data` ,当用户决定要存储的东西有点复杂了，可能向在另一个存储桶中来组织，那么就可以使用`add_bucket`来创建一个，并稍后往桶内添加内容。

```rust
fn add_key_data(para,buf) //插入一条新的叶子键值对
fn add_bucket(para,global:bool) //插入一个非叶子键值对
```

**move** : 传统文件系统中move用户移动文件或者目录，在统一模型下，则可能表达了用户想要从一个bucket中将数据移到另一个bucket中，

**rename** : rename在传统文件系统中，因为有inode和目录项的抽象，rename操作只会修改目录项的内容，而在统一模型下，rename表达了修改key的需求，如果key-value模型不提供修改功能，即只有删除和添加操作时，rename操作将会损害性能，尤其在其存储的数据很大时更为严重，因为这个操作将等价于删除和添加两个操作。

在统一模型上使用传统文件系统的操作是不太直观的，那么这时DBFS的作用就显现出来，毕竟DBFS就是为传统操作而设计。